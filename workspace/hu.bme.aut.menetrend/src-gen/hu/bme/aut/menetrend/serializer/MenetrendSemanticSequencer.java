/*
 * generated by Xtext 2.10.0
 */
package hu.bme.aut.menetrend.serializer;

import com.google.inject.Inject;
import hu.bme.aut.menetrend.menetrend.AbsoluteSchedule;
import hu.bme.aut.menetrend.menetrend.ComplexTimeEnd;
import hu.bme.aut.menetrend.menetrend.ComplexTimeMiddle;
import hu.bme.aut.menetrend.menetrend.LineNumber;
import hu.bme.aut.menetrend.menetrend.MenetrendPackage;
import hu.bme.aut.menetrend.menetrend.Model;
import hu.bme.aut.menetrend.menetrend.RelativeSchedule;
import hu.bme.aut.menetrend.menetrend.RelativeTarget;
import hu.bme.aut.menetrend.menetrend.Schedule;
import hu.bme.aut.menetrend.menetrend.SimpleTimeFormat;
import hu.bme.aut.menetrend.menetrend.Stop;
import hu.bme.aut.menetrend.services.MenetrendGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MenetrendSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MenetrendGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MenetrendPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MenetrendPackage.ABSOLUTE_SCHEDULE:
				sequence_AbsoluteSchedule(context, (AbsoluteSchedule) semanticObject); 
				return; 
			case MenetrendPackage.COMPLEX_TIME_END:
				sequence_ComplexTimeEnd(context, (ComplexTimeEnd) semanticObject); 
				return; 
			case MenetrendPackage.COMPLEX_TIME_MIDDLE:
				sequence_ComplexTimeMiddle(context, (ComplexTimeMiddle) semanticObject); 
				return; 
			case MenetrendPackage.LINE_NUMBER:
				sequence_LineNumber(context, (LineNumber) semanticObject); 
				return; 
			case MenetrendPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MenetrendPackage.RELATIVE_SCHEDULE:
				sequence_RelativeSchedule(context, (RelativeSchedule) semanticObject); 
				return; 
			case MenetrendPackage.RELATIVE_TARGET:
				sequence_RelativeTarget(context, (RelativeTarget) semanticObject); 
				return; 
			case MenetrendPackage.SCHEDULE:
				sequence_Schedule(context, (Schedule) semanticObject); 
				return; 
			case MenetrendPackage.SIMPLE_TIME_FORMAT:
				sequence_SimpleTimeFormat(context, (SimpleTimeFormat) semanticObject); 
				return; 
			case MenetrendPackage.STOP:
				sequence_Stop(context, (Stop) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SchedulePart returns AbsoluteSchedule
	 *     AbsoluteSchedule returns AbsoluteSchedule
	 *
	 * Constraint:
	 *     (daytype=DayType departures+=Departure departures+=Departure*)
	 */
	protected void sequence_AbsoluteSchedule(ISerializationContext context, AbsoluteSchedule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Departure returns ComplexTimeEnd
	 *     ComplexTimeEnd returns ComplexTimeEnd
	 *
	 * Constraint:
	 *     (from=TIME_FORMAT frequency=INT until=TIME_FORMAT)
	 */
	protected void sequence_ComplexTimeEnd(ISerializationContext context, ComplexTimeEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.DEPARTURE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.DEPARTURE__FROM));
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.COMPLEX_TIME_END__FREQUENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.COMPLEX_TIME_END__FREQUENCY));
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.COMPLEX_TIME_END__UNTIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.COMPLEX_TIME_END__UNTIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexTimeEndAccess().getFromTIME_FORMATTerminalRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getComplexTimeEndAccess().getFrequencyINTTerminalRuleCall_2_0(), semanticObject.getFrequency());
		feeder.accept(grammarAccess.getComplexTimeEndAccess().getUntilTIME_FORMATTerminalRuleCall_4_0(), semanticObject.getUntil());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Departure returns ComplexTimeMiddle
	 *     ComplexTimeMiddle returns ComplexTimeMiddle
	 *
	 * Constraint:
	 *     (from=TIME_FORMAT until=TIME_FORMAT frequency=INT)
	 */
	protected void sequence_ComplexTimeMiddle(ISerializationContext context, ComplexTimeMiddle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.DEPARTURE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.DEPARTURE__FROM));
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.COMPLEX_TIME_MIDDLE__UNTIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.COMPLEX_TIME_MIDDLE__UNTIL));
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.COMPLEX_TIME_MIDDLE__FREQUENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.COMPLEX_TIME_MIDDLE__FREQUENCY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexTimeMiddleAccess().getFromTIME_FORMATTerminalRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getComplexTimeMiddleAccess().getUntilTIME_FORMATTerminalRuleCall_2_0(), semanticObject.getUntil());
		feeder.accept(grammarAccess.getComplexTimeMiddleAccess().getFrequencyINTTerminalRuleCall_4_0(), semanticObject.getFrequency());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LineNumber returns LineNumber
	 *
	 * Constraint:
	 *     (type=TransportType (number=LineNumberInt | number=LineNumberBkvIdLf | number=LineNumberBkvIdLb))
	 */
	protected void sequence_LineNumber(ISerializationContext context, LineNumber semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (stops+=Stop stops+=Stop* schedules+=Schedule+)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SchedulePart returns RelativeSchedule
	 *     RelativeSchedule returns RelativeSchedule
	 *
	 * Constraint:
	 *     (start=[Stop|STRING] targets+=RelativeTarget+)
	 */
	protected void sequence_RelativeSchedule(ISerializationContext context, RelativeSchedule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelativeTarget returns RelativeTarget
	 *
	 * Constraint:
	 *     (length=INT target=[Stop|STRING])
	 */
	protected void sequence_RelativeTarget(ISerializationContext context, RelativeTarget semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.RELATIVE_TARGET__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.RELATIVE_TARGET__LENGTH));
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.RELATIVE_TARGET__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.RELATIVE_TARGET__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativeTargetAccess().getLengthINTTerminalRuleCall_1_0(), semanticObject.getLength());
		feeder.accept(grammarAccess.getRelativeTargetAccess().getTargetStopSTRINGTerminalRuleCall_3_0_1(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Schedule returns Schedule
	 *
	 * Constraint:
	 *     (lineNumber=LineNumber scheduleParts+=SchedulePart+)
	 */
	protected void sequence_Schedule(ISerializationContext context, Schedule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Departure returns SimpleTimeFormat
	 *     SimpleTimeFormat returns SimpleTimeFormat
	 *
	 * Constraint:
	 *     from=TIME_FORMAT
	 */
	protected void sequence_SimpleTimeFormat(ISerializationContext context, SimpleTimeFormat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.DEPARTURE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.DEPARTURE__FROM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTimeFormatAccess().getFromTIME_FORMATTerminalRuleCall_0(), semanticObject.getFrom());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stop returns Stop
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Stop(ISerializationContext context, Stop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MenetrendPackage.Literals.STOP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MenetrendPackage.Literals.STOP__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStopAccess().getNameSTRINGTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
